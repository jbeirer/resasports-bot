{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"No queues. Just gains.","text":"<p>PySportBot empowers you to programmatically book fitness classes at any sports center that uses the Resasports booking management software.</p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install pysportbot\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from pysportbot import SportBot\n\n# Create bot instance, will list available centres if requested\nbot = SportBot(log_level='INFO', print_centres=False, time_zone = 'Europe/Madrid')\n\n# Connect to service with email and password as well as the name of the centre\nbot.login('email', 'password', 'centre')\n\n# List available activites\nbot.activities(limit = 10)\n\n# List bookable slots for an activity on a specific day\nbot.daily_slots(activity='YourFavouriteGymClass', day = '2025-01-03', limit = 10)\n\n# Book an activity slot on a specific day and time\nbot.book(activity='YourFavouriteGymClass', start_time = '2024-12-30 07:00:00')\n\n# Cancel an activity slot on a specific day and time\nbot.cancel(activity='YourFavouriteGymClass', start_time = '2024-12-30 07:00:00')\n</code></pre>"},{"location":"#advanced-usage-as-service","title":"Advanced usage as service","text":"<p>You can easily run <code>pysportbot</code> as a service to manage your bookings automatically with</p> <pre><code>python -m pysportbot.service --config config.json\n</code></pre> <p>The service requires a <code>json</code> configuration file that specifies your user data and how you would like to book your classes. Currently, two types of configuration are supported:</p>"},{"location":"#1-book-an-upcoming-class-now","title":"1. Book an upcoming class now","text":"<p>Let's say you would like to book Yoga next Monday at 18:00:00, then your <code>config.json</code> would look like:</p> <pre><code>{\n    \"email\": \"your-email\",\n    \"password\": \"your-password\",\n    \"center\": \"your-gym-name\",\n    \"booking_execution\": \"now\",\n\n    \"classes\": [\n        {\n            \"activity\": \"Yoga\",\n            \"class_day\": \"Monday\",\n            \"class_time\": \"18:00:00\",\n        }\n    ]\n}\n</code></pre>"},{"location":"#2-book-an-upcoming-class-on-a-specific-day-and-time","title":"2. Book an upcoming class on a specific day and time","text":"<p>Let's say you would like to book Yoga next Monday at 18:00:00, but the execution of the booking should only happen on Friday at 07:30:00 then your <code>config.json</code> would look like:</p> <pre><code>{\n    \"email\": \"your-email\",\n    \"password\": \"your-password\",\n    \"center\": \"your-gym-name\",\n    \"booking_execution\": \"Friday 07:30:00\",\n\n    \"classes\": [\n        {\n            \"activity\": \"Yoga\",\n            \"class_day\": \"Monday\",\n            \"class_time\": \"18:00:00\",\n        }\n    ]\n}\n</code></pre> <p>Note: 1. Bookings are always scheduled for the following week. For example, if your booking execution is set for Friday at 07:30:00 and your class is on Friday at 18:00:00, the system will schedule the booking for next Friday at 18:00:00, not the same day. 2. PySportBot automatically attempts to execute up to N bookings in parallel, where N corresponds to the number of available CPU cores on your machine. 3. If the number of bookings exceeds the available parallel slots, they will be processed sequentially in the exact order specified in your JSON configuration file.</p> <p>The service also provides various other options that can be inspected with</p> <pre><code>python -m pysportbot.service --help\n</code></pre> <p>Currently supported options include:</p> <ol> <li><code>--booking-delay</code>: sets a global delay in seconds before booking execution [default: 0]</li> <li><code>--retry-attempts</code>: sets the number of retries attempted in case a booking attempt fails [default: 3]</li> <li><code>--retry-delay</code>: sets the delay in seconds between booking retries [default: 5]</li> <li><code>--time-zone</code>: sets the time zone for the service [default: Europe/Madrid]</li> <li><code>--log-level</code>: sets the log-level of the service [default: INFO]</li> <li><code>--max-threads</code>: limits the number of used threads for parallel bookings [default: -1]</li> </ol>"},{"location":"#automating-weekly-bookings-with-github-actions","title":"Automating Weekly Bookings with GitHub Actions","text":"<p>While you can use PySportBot as a continuously running service, doing so often becomes cumbersome because it requires a server (or similar machine) that is always online.</p> <p>Using GitHub Actions is one of the most reliable ways to schedule automated weekly bookings. With a simple workflow file, you can ensure your bookings run at a specific time each week \u2014 no manual intervention required.</p> <p>For example, if you have a Yoga class on Monday at 18:00:00, and you want the booking to be executed on Friday at 07:30:00, you can automate the process by configuring a GitHub Actions workflow. Below is a sample workflow file that triggers every Friday at 06:00 UTC (07:00 CET), ensuring there is enough time before the actual booking execution at 07:30:00:</p> <pre><code>name: Weekly Booking\n\non:\n  # Runs at 05:00 UTC (07:00 Madrid time during daylight saving time) on Fridays\n  # Note: Update to '0 6 * * 5' for winter (standard) time when Madrid shifts to UTC+1\n  # GitHub Actions cron expressions are always in UTC and do not support time zones\n  # Reference: https://github.com/orgs/community/discussions/13454\n  schedule:\n    - cron: '0 5 * * 5'\n\njobs:\n  book:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Check out repository\n        uses: actions/checkout@v5\n\n      - name: Set up Python 3.12\n        uses: actions/setup-python@v6\n        with:\n          python-version: '3.12'\n\n      - name: Install pysportbot\n        run: |\n          pip install pysportbot\n\n      - name: Create config file\n        run: |\n          echo '{\n            \"email\": \"your-email\",\n            \"password\": \"your-password\",\n            \"centre\": \"your-gym\",\n            \"booking_execution\": \"Friday 07:30:00\",\n            \"classes\": [\n              {\n                \"activity\": \"Yoga\",\n                \"class_day\": \"Monday\",\n                \"class_time\": \"18:00:00\"\n              }\n            ]\n          }' &gt; config.json\n\n      - name: Run pysportbot\n        run: |\n          python -m pysportbot.service --config config.json --log-level INFO --booking-delay 1 --retry-attempts 3 --retry-delay 5\n</code></pre> <p>Note: Make sure the workflow starts early enough \u2014 before your booking execution time (e.g., 07:30 CET) \u2014 to allow for potential delays in job startup or execution.</p>"},{"location":"#license","title":"LICENSE","text":"<p>pysportbot is free of use and open-source. All versions are published under the MIT License.</p>"},{"location":"modules/","title":"Modules","text":""},{"location":"modules/#pysportbot.SportBot","title":"<code>SportBot</code>","text":"<p>Unified interface for interacting with the booking system.</p> Source code in <code>pysportbot/__init__.py</code> <pre><code>class SportBot:\n    \"\"\"Unified interface for interacting with the booking system.\"\"\"\n\n    def __init__(self, log_level: str = \"INFO\", print_centres: bool = False, time_zone: str = \"Europe/Madrid\") -&gt; None:\n        setup_logger(log_level, timezone=time_zone)\n        self._logger = logging.getLogger(\"SportBot\")\n        self._logger.info(\"Initializing SportBot...\")\n        self._logger.info(f\"Log level: {log_level}\")\n        self._logger.info(f\"Time zone: {time_zone}\")\n        self._centres = Centres(print_centres)\n        self._session: Session = Session()\n        self._auth: Authenticator | None = None\n        self._activities: Activities | None = None\n        self._bookings: Bookings | None = None\n        self._df_activities: DataFrame | None = None\n        self._is_logged_in: bool = False\n\n    @property\n    def activities_manager(self) -&gt; Activities:\n        \"\"\"Get the activities manager, ensuring user is logged in.\"\"\"\n        if not self._is_logged_in or self._auth is None:\n            raise PermissionError(ErrorMessages.not_logged_in())\n\n        # Lazy initialization - create only when first needed\n        if self._activities is None:\n            self._activities = Activities(self._auth)\n        return self._activities\n\n    @property\n    def bookings_manager(self) -&gt; Bookings:\n        \"\"\"Get the bookings manager, ensuring user is logged in.\"\"\"\n        if not self._is_logged_in or self._auth is None:\n            raise PermissionError(ErrorMessages.not_logged_in())\n\n        # Lazy initialization - create only when first needed\n        if self._bookings is None:\n            self._bookings = Bookings(self._auth)\n        return self._bookings\n\n    def set_log_level(self, log_level: str) -&gt; None:\n        set_log_level(log_level)\n        self._logger.info(f\"Log level changed to {log_level}.\")\n\n    def login(self, email: str, password: str, centre: str) -&gt; None:\n        # Check if the selected centre is valid\n        self._centres.check_centre(centre)\n        self._logger.info(f\"Selected centre: {centre}\")\n\n        # Initialize the Authenticator\n        self._auth = Authenticator(self._session, centre)\n\n        self._logger.info(\"Attempting to log in...\")\n        try:\n            # Login to get valid credentials\n            self._auth.login(email, password)\n            self._is_logged_in = True\n            self._logger.info(\"Login successful!\")\n\n            # Fetch activities on first successful login\n            self._df_activities = self.activities_manager.fetch()\n        except Exception:\n            self._is_logged_in = False\n            # Clean up on failure\n            self._activities = None\n            self._bookings = None\n            self._auth = None\n            self._logger.exception(ErrorMessages.login_failed())\n            raise\n\n    def is_logged_in(self) -&gt; bool:\n        \"\"\"Returns the login status.\"\"\"\n        return self._is_logged_in\n\n    def activities(self, limit: int | None = None) -&gt; DataFrame:\n        if self._df_activities is None:\n            raise ValueError(ErrorMessages.no_activities_loaded())\n\n        df = self._df_activities[[\"name_activity\", \"id_activity\"]]\n        return df.head(limit) if limit else df\n\n    def daily_slots(self, activity: str, day: str, limit: int | None = None) -&gt; DataFrame:\n        if self._df_activities is None:\n            raise ValueError(ErrorMessages.no_activities_loaded())\n\n        df = self.activities_manager.daily_slots(self._df_activities, activity, day)\n        return df.head(limit) if limit else df\n\n    def book(self, activity: str, start_time: str) -&gt; None:\n        if self._df_activities is None:\n            raise ValueError(ErrorMessages.no_activities_loaded())\n\n        # Fetch the daily slots for the activity\n        slots = self.daily_slots(activity, start_time.split(\" \")[0])\n\n        # Find the slot that matches the start time\n        matching_slot = slots[slots[\"start_timestamp\"] == start_time]\n\n        # If no matching slot is found, raise an error\n        if matching_slot.empty:\n            error_msg = ErrorMessages.slot_not_found(activity, start_time)\n            self._logger.error(error_msg)\n            raise IndexError(error_msg)\n\n        # The targeted slot\n        target_slot = matching_slot.iloc[0]\n        # The unique slot ID\n        slot_id = target_slot[\"id_activity_calendar\"]\n        # The total member capacity of the slot\n        slot_capacity = target_slot[\"n_capacity\"]\n        # The number of members already inscribed in the slot\n        slot_n_inscribed = target_slot[\"n_inscribed\"]\n        # Log slot capacity\n        self._logger.info(\n            f\"Attempting to book class '{activity}' on {start_time} with ID {slot_id} (Slot capacity: {slot_n_inscribed}/{slot_capacity})\"\n        )\n\n        # Check if the slot is already booked out\n        if slot_n_inscribed &gt;= slot_capacity:\n            self._logger.error(f\"Activity '{activity}' on {start_time} with ID {slot_id} is booked out...\")\n            raise ValueError(ErrorMessages.slot_capacity_full())\n\n        # Attempt to book the slot\n        try:\n            self.bookings_manager.book(slot_id)\n            self._logger.info(f\"Successfully booked class '{activity}' on {start_time}\")\n        except ValueError:\n            self._logger.error(f\"Failed to book class '{activity}' on {start_time}\")\n\n    def cancel(self, activity: str, start_time: str) -&gt; None:\n        self._logger.debug(f\"Attempting to cancel class '{activity}' on {start_time}\")\n\n        if self._df_activities is None:\n            raise ValueError(ErrorMessages.no_activities_loaded())\n\n        slots = self.daily_slots(activity, start_time.split(\" \")[0])\n        matching_slot = slots[slots[\"start_timestamp\"] == start_time]\n        if matching_slot.empty:\n            error_msg = ErrorMessages.slot_not_found(activity, start_time)\n            self._logger.error(error_msg)\n            raise IndexError(error_msg)\n\n        slot_id = matching_slot.iloc[0][\"id_activity_calendar\"]\n        try:\n            self.bookings_manager.cancel(slot_id)\n            self._logger.info(f\"Successfully cancelled class '{activity}' on {start_time}\")\n        except ValueError:\n            self._logger.error(f\"Failed to cancel class '{activity}' on {start_time}\")\n</code></pre>"},{"location":"modules/#pysportbot.SportBot.activities_manager","title":"<code>activities_manager</code>  <code>property</code>","text":"<p>Get the activities manager, ensuring user is logged in.</p>"},{"location":"modules/#pysportbot.SportBot.bookings_manager","title":"<code>bookings_manager</code>  <code>property</code>","text":"<p>Get the bookings manager, ensuring user is logged in.</p>"},{"location":"modules/#pysportbot.SportBot.is_logged_in","title":"<code>is_logged_in()</code>","text":"<p>Returns the login status.</p> Source code in <code>pysportbot/__init__.py</code> <pre><code>def is_logged_in(self) -&gt; bool:\n    \"\"\"Returns the login status.\"\"\"\n    return self._is_logged_in\n</code></pre>"}]}